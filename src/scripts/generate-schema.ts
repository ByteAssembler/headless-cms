import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';
import { allContentTypeConfigs } from '@/content-types';
import { type FieldDefinition } from '@/core/content-fields';

// --- Configuration ---
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const outputFilePath = path.resolve(__dirname, '../output/database.schema.ts');

// Map apiIdentifier to the *variable name* of the imported config
// This is crucial for generating the correct code referencing the imports
const configVariableNames: Record<string, string> = {
	'users': 'usersConfig',
	'posts': 'postsConfig',
	'categories': 'categoriesConfig',
	'session': 'sessionConfig',
	'account': 'accountConfig',
	'verification': 'verificationConfig'
};

// --- Generation Logic ---
console.log("Starting schema generation with direct type references...");

const manyToManyRelations: { fromTable: string, toTable: string, fieldName: string }[] = [];
const tableNames: string[] = [];
const relationConstNames: string[] = [];
const joinTableNames: string[] = [];

let importStatements = `// THIS FILE IS AUTO-GENERATED BY scripts/generate-schema.ts
// DO NOT EDIT THIS FILE DIRECTLY!

import { sqliteTable, text, integer, real, blob, primaryKey } from 'drizzle-orm/sqlite-core';
import { relations } from 'drizzle-orm';
import type { AnySQLiteColumn, AnySQLiteTable } from 'drizzle-orm/sqlite-core';

// Import the necessary configs and definitions for type safety
import {
	allContentTypeConfigs, // Keep for potential dynamic checks if needed
	// Import specific configs used in table definitions
`;

// Dynamically add imports for each config variable name
Object.values(configVariableNames).forEach(varName => {
	importStatements += `	${varName},\n`;
});
importStatements += `} from '@/content-types';
import { defineIdField, defineTimestamps } from '@/core/content-fields';

console.log("[Schema] Generated schema definitions loading...");

`;

let tableDefinitions = '// --- Generated Table Definitions ---\n';
let relationDefinitions = '// --- Generated Relation Definitions ---\n';
let schemaObjectEntries = '';

// 1. Generate Base Table Definitions using direct references
console.log("Generating base tables with direct references...");
for (const apiIdentifier in allContentTypeConfigs) {
	const config = allContentTypeConfigs[apiIdentifier];
	const configVarName = configVariableNames[apiIdentifier]; // Get the variable name (e.g., 'authUserConfig')

	if (!configVarName) {
		console.warn(`[Generator] No variable name mapping found for apiIdentifier: ${apiIdentifier}. Skipping table generation.`);
		continue;
	}

	tableNames.push(apiIdentifier);
	schemaObjectEntries += `\t${apiIdentifier},\n`;

	tableDefinitions += `export const ${apiIdentifier} = sqliteTable('${apiIdentifier}', {\n`;
	// Standard ID field
	tableDefinitions += `  id: defineIdField().column,\n`; // Use imported definition

	// Content Fields
	for (const fieldName in config.fields) {
		const fieldDef = config.fields[fieldName] as FieldDefinition<any, any, any, any>;

		// Skip standard timestamps defined directly in fields (they are added below)
		if (fieldName === 'createdAt' || fieldName === 'updatedAt') continue;

		if (fieldDef.column) { // Generate column if defined
			// Use fieldName + 'Id' convention for M2O foreign key columns
			const columnName = (fieldDef.config.relationTo && !fieldDef.config.many) ? `${fieldName}Id` : fieldName;
			// Reference the imported config and field definition's column
			tableDefinitions += `  ${columnName}: ${configVarName}.fields.${fieldName}.column,\n`;
		} else if (fieldDef.config.relationTo && fieldDef.config.many) {
			// Register M2M relation for join table and relation generation
			manyToManyRelations.push({ fromTable: apiIdentifier, toTable: fieldDef.config.relationTo, fieldName: fieldName });
		}
	}

	// Timestamps (using definitions from defineTimestamps)
	tableDefinitions += `  createdAt: defineTimestamps().createdAt.column,\n`; // Use imported definition
	tableDefinitions += `  updatedAt: defineTimestamps().updatedAt.column,\n`; // Use imported definition

	tableDefinitions += `});\n\n`;
	console.log(`  Generated definition for table: ${apiIdentifier} using direct references.`);
}

// 2. Generate Join Table Definitions (Structure remains similar, references are now direct)
console.log("Generating join tables...");
const createdJoinTables = new Set<string>();
for (const m2m of manyToManyRelations) {
	// Sort table names alphabetically for consistent join table naming
	const [tableA, tableB] = [m2m.fromTable, m2m.toTable].sort();
	const joinTableName = `${tableA}_to_${tableB}`;

	if (createdJoinTables.has(joinTableName)) {
		continue; // Avoid duplicate join table definitions
	}

	tableNames.push(joinTableName);
	joinTableNames.push(joinTableName); // Keep track for relation generation
	schemaObjectEntries += `\t${joinTableName},\n`;

	tableDefinitions += `export const ${joinTableName} = sqliteTable('${joinTableName}', {\n`;
	// Foreign Key Columns referencing the base tables' id columns
	// References now use the generated table objects directly
	tableDefinitions += `  ${tableA}Id: text('${tableA}Id').notNull().references(() => ${tableA}.id, { onDelete: 'cascade', onUpdate: 'cascade' }),\n`;
	tableDefinitions += `  ${tableB}Id: text('${tableB}Id').notNull().references(() => ${tableB}.id, { onDelete: 'cascade', onUpdate: 'cascade' }),\n`;
	tableDefinitions += `}, (table) => ({\n`;
	// Composite Primary Key
	tableDefinitions += `  pk: primaryKey({ columns: [table.${tableA}Id, table.${tableB}Id] })\n`;
	tableDefinitions += `}));\n\n`;

	createdJoinTables.add(joinTableName);
	console.log(`  Generated definition for join table: ${joinTableName}`);
}

// 3. Generate Base Table Relations (Structure remains similar, references are now direct)
console.log("Generating base table relations...");
for (const apiIdentifier in allContentTypeConfigs) {
	const config = allContentTypeConfigs[apiIdentifier];
	const configVarName = configVariableNames[apiIdentifier];
	const relationsForTable: string[] = [];

	if (!configVarName) continue; // Skip if no mapping

	// --- Define M2O and M2M relations originating FROM this table ---
	for (const fieldName in config.fields) {
		const fieldDef = config.fields[fieldName] as FieldDefinition<any, any, any, any>;

		if (fieldDef.config.relationTo) {
			const targetTable = fieldDef.config.relationTo;
			if (fieldDef.config.many) {
				// Many-to-Many: Relation points to the join table
				const joinTableName = [apiIdentifier, targetTable].sort().join('_to_');
				if (createdJoinTables.has(joinTableName)) {
					relationsForTable.push(`  ${fieldName}: many(${joinTableName})`);
				} else {
					console.warn(`[Generator] Join table ${joinTableName} not found for M2M relation ${apiIdentifier}.${fieldName}. Relation skipped.`);
				}
			} else {
				// Many-to-One: Relation points to the target table via FK
				const fkColumnName = `${fieldName}Id`;
				// Check if the field definition implies a column (M2O relations have a column)
				if (fieldDef.column) {
					// Reference the generated table objects directly
					relationsForTable.push(`  ${fieldName}: one(${targetTable}, {\n    fields: [${apiIdentifier}.${fkColumnName}],\n    references: [${targetTable}.id]\n  })`);
				} else {
					console.warn(`[Generator] FK column ${fkColumnName} missing for M2O relation ${apiIdentifier}.${fieldName}. Relation skipped.`);
				}
			}
		}
	}

	// --- Define O2M relations pointing TO this table ---
	for (const otherApiIdentifier in allContentTypeConfigs) {
		if (otherApiIdentifier === apiIdentifier) continue; // Skip self-reference check here
		const otherConfig = allContentTypeConfigs[otherApiIdentifier];
		for (const otherFieldName in otherConfig.fields) {
			const otherFieldDef = otherConfig.fields[otherFieldName] as FieldDefinition<any, any, any, any>;
			// Check if a field in another table points to *this* table (apiIdentifier) via M2O
			if (otherFieldDef.config.relationTo === apiIdentifier && !otherFieldDef.config.many) {
				const relationName = otherApiIdentifier; // Simple naming: use the other table's apiIdentifier
				// Avoid adding duplicate relation names
				if (!relationsForTable.some(rel => rel.trim().startsWith(`${relationName}:`))) {
					// Reference the generated table object directly
					relationsForTable.push(`  ${relationName}: many(${otherApiIdentifier})`);
				}
			}
		}
	}


	if (relationsForTable.length > 0) {
		const relationConstName = `${apiIdentifier}Relations`;
		relationConstNames.push(relationConstName);
		schemaObjectEntries += `\t${relationConstName},\n`;

		// Reference the generated table object directly
		relationDefinitions += `export const ${relationConstName} = relations(${apiIdentifier}, ({ one, many }) => ({\n`;
		relationDefinitions += relationsForTable.join(',\n');
		relationDefinitions += `\n}));\n\n`;
		console.log(`  Generated relations for: ${apiIdentifier}`);
	} else {
		console.log(`  No relations defined for: ${apiIdentifier}`);
	}
}

// 4. Generate Join Table Relations (Structure remains similar, references are now direct)
console.log("Generating join table relations...");
for (const joinTableName of createdJoinTables) {
	const [tableA, tableB] = joinTableName.split('_to_');
	const relationConstName = `${joinTableName}Relations`;
	relationConstNames.push(relationConstName);
	schemaObjectEntries += `\t${relationConstName},\n`;

	// Reference the generated table objects directly
	relationDefinitions += `export const ${relationConstName} = relations(${joinTableName}, ({ one }) => ({\n`;
	relationDefinitions += `  ${tableA}: one(${tableA}, {\n    fields: [${joinTableName}.${tableA}Id],\n    references: [${tableA}.id]\n  }),\n`;
	relationDefinitions += `  ${tableB}: one(${tableB}, {\n    fields: [${joinTableName}.${tableB}Id],\n    references: [${tableB}.id]\n  })\n`;
	relationDefinitions += `}));\n\n`;
	console.log(`  Generated relations for join table: ${joinTableName}`);
}


// 5. Build the final output file content
let outputContent = importStatements;
outputContent += tableDefinitions;
outputContent += relationDefinitions;

outputContent += `console.log("[Schema] Defining final schema object...");

// --- Generated Schema Object ---
export const schema = {
${schemaObjectEntries}};

console.log("[Schema] Generation complete.");

// --- Type Helpers ---
export type Schema = typeof schema;
export type TableName = ${tableNames.map(name => `\'${name}\'`).join(' | ') || 'never'};
export type RelationName = ${relationConstNames.map(name => `\'${name}\'`).join(' | ') || 'never'};

// Helper type for tables with a standard 'id' column
export type TableWithId = Extract<Schema[TableName], AnySQLiteTable & { id: AnySQLiteColumn }>;
`;

// 6. Write the generated content to the output file
try {
	fs.writeFileSync(outputFilePath, outputContent, 'utf8');
	console.log(`Successfully generated schema with direct type references at: ${outputFilePath}`);
} catch (error) {
	console.error(`Error writing schema file to ${outputFilePath}:`, error);
	process.exit(1); // Exit with error code
}

// 7. Reminder to remove obsolete files
console.log("\nReminder: You can now likely remove the following files as they are obsolete:");
console.log("- src/db/generation-logic.ts");
console.log("- src/core/schema-relations.ts");
